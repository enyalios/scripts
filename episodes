#!/usr/bin/perl

use strict;
use warnings;
use LWP::UserAgent;
use Data::Dumper;
use Getopt::Std;

my $cache_file = "/tmp/episode_cache";
my ($title, $subtitle, $ext, %data, %opts);

sub get {
    my $url = $_[0];
    my $ua = LWP::UserAgent->new;
    # act like mozilla since google hates LWP
    $ua->agent('Mozilla/5.0'); 
    $ua->get($url)->content;
}

sub parse_args {
    getopts('luhvcdi', \%opts);
    HELP_MESSAGE() if $opts{h};
    if(@ARGV == 2) { 
        ($title, $subtitle) = @ARGV;
    }
    elsif(@ARGV == 1) {
      if( $opts{d} ){
        ($title, $subtitle, $ext) = $ARGV[0] =~ 
        /^(.+?) - (?:[-\dsex]* - )?(.+?)(\.[a-z]{2,4})?$/i;
      }
      else{
        ($title, $subtitle, $ext) = $ARGV[0] =~ 
        /^(.+?)[- _]+[-\dsex]*[- _]+(.+?)(\.[a-z]{2,4})?$/i;
      }
        $title ||= $ARGV[0];

	  #print "$title|$subtitle|$ext\n";
    }
    else { 
        print "bad arguments\n"; 
        HELP_MESSAGE(); 
    }
    for($title, $subtitle) { y/_/ / if $_ };
    $ext ||= "";
}

sub HELP_MESSAGE {
    print <<EOF;

usage:
    episodes <options> <title>
    episodes <options> <title> <subtitle>
    episodes <options> <filename>

options:
    -c    cache-only (skip internet lookups)
    -i    internet-only (skip cache lookup)
    -h    print help message
    -l    lowercase filenames
    -u    convert spaces to underscores
    -v    verbose info
    -d    segments of the title are delimited with the ' - ' squence

EOF
    exit 1;
}
        
sub simple {
    my $word = $_[0] || "";
    for($word) { s/&#\d+?;/'/g; y/A-Z /a-z_/; y/-a-z_0-9//cd; }
    return $word;
}

sub load_cache {
    -e $cache_file ? %{do $cache_file} : ();
}

sub find_match {
  my $simp_sub = simple($subtitle);

    my $result = $data{simple($title)}{$simp_sub} || "";
    unless($result) {
        for(keys %{$data{simple($title)}}) {
            $result = $data{simple($title)}{$_} if /$simp_sub.*/;
        }
    }
    unless($result) {
        for(keys %{$data{simple($title)}}) {
            $result = $data{simple($title)}{$_} if /.*$simp_sub.*/;
        }
    }
  # This code fixes a problem where if you search for a show with & in the
  # title it works and returns and where as if you search for title with the
  # and the search fails. I'm sure there are other such times that can be
  # added here.
    unless($result) {
      $simp_sub =~ s/and//g;
      for(keys %{$data{simple($title)}}) {
	$result = $data{simple($title)}{$_} if /.*$simp_sub.*/;
      }
    }
    return format_match($result);
}

sub grab_eps {
    # invalidate the cache for this show
    delete $data{simple($title)};

    # find the url of the episode listing for the given show
    (my $show_url) = get("http://www.google.com/search?hl=en&q=allintitle%3A+site%3Atv.com+$title&btnG=Search")
        =~ m!href="(http://www.tv.com/.*?/summary.html)!;
    ($title) = get("$show_url") =~ m!<title>(.*?) - TV\.com </title>!;
    die "could not find any show by that name!\n" unless $show_url;
    $show_url =~ s/summary\.html$/episode_listings.html/;
    print "\$show_url: $show_url\n" if $opts{v};

    # loop over the episode pages and print out the episodes
    # using this page first, follow by any other season pages
    (my $season_url = $show_url) =~ s/summary\.html$/episode_listings.html/;
    my @seasons = 1.. (get("$season_url?season=1") =~ /<a href=".*?episode_listings.html\?season=(\d+)"/g)[0]; 
    $seasons[0] = 1 unless @seasons;
    my $season_length = length $seasons[-1];
    for(@seasons) {
        print "  getting season page: $_\n" if $opts{v};
        my ($season_num) = $_;
        my $ep_num = 1;
        my $page = get( $season_url . "?season=" . $_ );
        for ($page =~ m!(<tr class=.*?<td class="ep_title">.*?<td class="ep_air_date">)!g) {

            m!^<tr class=".*?"><td class="num"><div>(\d+|Special)\s*</div></td>\s*<td class="ep_title"><div><a href="http://www\.tv\.com.*?">(.*)</a>!;

            my $ep_title = $2;
            next unless $ep_title;

            # this code starts us using the right number if a "Piolt" episode in
            # first season is listed as Pilot and the next episode starts at
            # number 2. This occurs to futurama, currently the pilot episode
            # is still skipped. a 2 pass aproach seems the only way to really
            # solve this, and not scew up shows like star trek where the pilot is
            # not counted in the first season

            if( $1 ne $ep_num &&
                $ep_num == 1 &&
                $season_num == 1){
                $ep_num = $1;
                print "    using data suplied starting ep number: $1\n" if $opts{v};
            }

            $ep_title =~ s/\xC0/A/g;
            $ep_title =~ s/\xE0/a/g;
            $ep_title =~ s/\xE9/e/g;

            print "   found episode: $ep_title\n" if $opts{v};

            $data{simple($title)}{simple($ep_title)} = sprintf("%s - %0*d%02d - %s", $title, $season_length, $season_num, $ep_num++, $ep_title);
        }
    }
    write_cache();
}

sub write_cache {
    open CACHE, ">$cache_file" 
        or die "could not open '$cache_file' for writing: $!\n";
    print CACHE Dumper \%data;
    close CACHE;
}

sub format_match {
    $_[0] =~ s/&#039/'/g;
    $_[0] =~ s/&/and/g;
    $_[0] =~ y/-_A-Za-z0-9 .,'()%?!//cd;
    $_[0] = lc $_[0] if $opts{l};
    $_[0] =~ s/ (- )?/_/g if $opts{u};
    $_[0] =~ y/-a-z_0-9//cd if($opts{u} && $opts{l});
    return $_[0];
}

parse_args();
%data = load_cache();
if($subtitle) {
    my $match = find_match() unless $opts{i};
    if(!$match && !$opts{c}) {
        grab_eps();
        $match = find_match();
    }
    print $match ? "$match" : format_match("$title  $subtitle"), "$ext\n"; 
} else {
    grab_eps() if ($opts{i} || !$data{simple($title)});
    print format_match($_), "\n" for sort values %{$data{simple($title)}};
}
