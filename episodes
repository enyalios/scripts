#!/usr/bin/perl

use strict;
use warnings;
use LWP::Simple;
use Data::Dumper;
use Getopt::Std;

my $cache_file = "/tmp/episode_cache";
my ($title, $subtitle, $ext, %data, %opts);

sub parse_args {
    getopts('luhvcd', \%opts);
    HELP_MESSAGE() if $opts{h};
    if(@ARGV == 2) { 
        ($title, $subtitle) = @ARGV;
    }
    elsif(@ARGV == 1) {
      if( $opts{d} ){
        ($title, $subtitle, $ext) = $ARGV[0] =~ 
        /^(.+?) - (?:[-\dsex]* - )?(.+?)(\.[a-z]{2,4})?$/i;
      }
      else{
        ($title, $subtitle, $ext) = $ARGV[0] =~ 
        /^(.+?)[- _]+[-\dsex]*[- _]+(.+?)(\.[a-z]{2,4})?$/i;
      }
        $title ||= $ARGV[0];

	  #print "$title|$subtitle|$ext\n";
    }
    else { 
        print "bad arguments\n"; 
        HELP_MESSAGE(); 
    }
    for($title, $subtitle) { y/_/ / if $_ };
    $ext ||= "";
}

sub HELP_MESSAGE {
    print <<EOF;

usage:
    episodes <options> <title>
    episodes <options> <title> <subtitle>
    episodes <options> <filename>

options:
    -c    cache-only (skip internet lookups)
    -h    print help message
    -l    lowercase filenames
    -u    convert spaces to underscores
    -v    verbose info
    -d    segments of the title are delimited with the ' - ' squence

EOF
    exit 1;
}
        
sub simple {
    my $word = $_[0] || "";
    for($word) { y/A-Z /a-z_/; y/-a-z_0-9//cd; }
    return $word;
}

sub load_cache {
    -e $cache_file ? %{do $cache_file} : ();
}

sub find_match {
  my $simp_sub = simple($subtitle);

    my $result = $data{simple($title)}{$simp_sub} || "";
    unless($result) {
        for(keys %{$data{simple($title)}}) {
            $result = $data{simple($title)}{$_} if /$simp_sub.*/;
        }
    }
    unless($result) {
        for(keys %{$data{simple($title)}}) {
            $result = $data{simple($title)}{$_} if /.*$simp_sub.*/;
        }
    }
  # This code fixes a problem where if you search for a show with & in the
  # title it works and returns and where as if you search for title with the
  # and the search fails. I'm sure there are other such times that can be
  # added here.
    unless($result) {
      $simp_sub =~ s/and//g;
      for(keys %{$data{simple($title)}}) {
	$result = $data{simple($title)}{$_} if /.*$simp_sub.*/;
      }
    }
    return format_match($result);
}

sub grab_eps {
    # invalidate the cache for this show
    delete $data{simple($title)};

    # find the url of the episode listing for the given show
    (my $show_url, $title ) = get("http://www.tv.com/search.php?stype=all&qs=$title") 
        =~ /<a class="f-bold f-C30" href="(.*summary\.html).*?">(.*?)<\/a>/;
    die "could not find any show by that name!\n" unless $show_url;
    $show_url =~ s/summary\.html$/episode_listings.html/;
    print "\$show_url: $show_url\n" if $opts{v};

    # loop over the episode pages and print out the episodes
    # using this page first, follow by any other season pages
    my @seasons = ("$show_url?season=1", get("$show_url") =~ /<option value="(.*season=(?:[2-9]|[1-9]\d+))(?!\d)/g);
    my $season_length = length(($seasons[-1] =~ /(\d+)$/)[0]);
    for(@seasons) {
        print "  getting season page: $_\n" if $opts{v};
        my ($season_num) = /(\d+)$/;
        my $ep_num = 1;
        my $page = get $_;
        for ($page =~ m!(^\s+(?:\d+|Special)\s+</td>\s+<td class="f-bold">\s+<a href="[^"]+episode/\d+/summary.html.*?">.*</a>)!mg) {
	
	  $_ =~ m!^\s+(\d+|Special)\s+</td>\s+<td class="f-bold">\s+<a href="[^"]+episode/\d+/summary.html.*?">(.*)</a>!;
	
	  my $ep_title = $2;


	  # this code starts us using the right number if a "Piolt" episode in
	  # first season is listed as Pilot and the next episode starts at
	  # number 2. This occurs to futurama, currently the pilot episode
	  # is still skipped. a 2 pass aproach seems the only way to really
	  # solve this, and not scew up shows like star trek where the pilot is
	  # not counted in the first season
	
	  if( $1 ne $ep_num &&
	 	$ep_num == 1 &&
		 $season_num == 1){
	    $ep_num = $1;
	    print "    using data suplied starting ep number: $1\n" if $opts{v};
	  }

          print "   found episode: $ep_title\n" if $opts{v};
	  $data{simple($title)}{simple($2)} = sprintf("%s - %0*d%02d - %s", $title, $season_length, $season_num, $ep_num++, $ep_title);
        }
    }
    write_cache();
}

sub write_cache {
    open CACHE, ">$cache_file" 
        or die "could not open '$cache_file' for writing: $!\n";
    print CACHE Dumper \%data;
    close CACHE;
}

sub format_match {
    $_[0] =~ s/&/and/g;
    $_[0] =~ y/-_A-Za-z0-9 .,'()%?!//cd;
    $_[0] = lc $_[0] if $opts{l};
    $_[0] =~ s/ (- )?/_/g if $opts{u};
    $_[0] =~ y/-a-z_0-9//cd if($opts{u} && $opts{l});
    return $_[0];
}

parse_args();
%data = load_cache();
if($subtitle) {
    my $match = find_match();
    if(!$match && !$opts{c}) {
        grab_eps();
        $match = find_match();
    }
    print $match ? "$match" : format_match("$title  $subtitle"), "$ext\n"; 
} else {
    grab_eps() unless $data{simple($title)};
    print format_match($_), "\n" for sort values %{$data{simple($title)}};
}
