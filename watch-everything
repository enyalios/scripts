#!/usr/bin/perl

use strict;
#use warnings;
use LWP::Simple;
use Data::Dumper;
use MIME::Base64;
use Term::ReadKey;
use Term::ANSIColor;
use Term::Cap;
use POSIX;

# these are for exchange
use SOAP::Lite maptype=>{};
use SOAP::Transport::HTTP;
use Date::Parse; # from dev-perl/TimeDate

# set up some variables
my $user = "guder";
my $delay = 0;
$delay = $ARGV[0] if(defined $ARGV[0] && $ARGV[0] =~ /\d+/);

my ($buffer, $width, $height);
$| = 1;

my $pass = get_password();

# make the cursor dissappear if we're a daemon
$SIG{INT} = sub { &fix_term && exit };
END { &fix_term }
sub fix_term { print "\e[?25h"; }
print "\e[?25l" if $delay;

my $ua = LWP::UserAgent->new;
my $r = HTTP::Request->new(GET => 'https://smgmon.cites.illinois.edu/nagios/cgi-bin/short-details.cgi');
my $auth = MIME::Base64::encode("$user:$pass");
$r->header(Authorization => "Basic $auth");
while(1) {
    ($width, $height, undef, undef) = GetTerminalSize();
    $buffer = "";

    &check_nagios();
    &check_calendar();
    &check_email();
    &check_irc();
    &check_jabber();

    # bail if we're not a daemon, since we already printed everything
    last unless $delay;

    &clear_screen();
    $buffer = &get_header() . $buffer;
    $buffer = &truncate($buffer);
    $buffer = &colorize($buffer);
    print $buffer;
    sleep $delay;
}

sub output {
    return unless defined $_[0];
    print $_[0] and return unless $delay;
    # add newlines so that no lines wrap
    $_ = $_[0];
    1 while s/^(.{$width})(?!\n)/$1\n/m;
    $buffer .= $_;
}

sub get_password {
    print "$user\'s AD password: ";
    ReadMode('noecho');
    my $pw = ReadLine(0);
    ReadMode('normal');
    chomp $pw;
    print "\n";
    return $pw;
}

sub clear_screen {
    my $termios = POSIX::Termios->new;
    $termios->getattr;
    my $term = Term::Cap->Tgetent( { OSPEED => $termios->getospeed } );
    $term->Tputs('cl', 1, *STDOUT);
}

sub get_header {
    # generate a nice header like the one 'watch' prints
    my $lheader = "Every $delay.0s: $0";
    my $rheader = localtime;
    return $lheader . " " x ($width - length($rheader) - length($lheader)) . $rheader . "\n\n";
}

sub truncate {
    # truncate the buffer so it doesnt scroll off the screen
    my $buffer = $_[0];
    $buffer =~ s/^((?:.*\n){1,$height})[\s\S]*/$1/;
    $buffer =~ s/\n$//;
    return $buffer;
}

sub colorize {
    # color probes that arent ack'ed
    my $buffer = $_[0];
    $buffer =~ s/(.*     WARNING .*)/color('YELLOW') . $1 . color('RESET')/eg;
    $buffer =~ s/(.*     CRITICAL .*)/color('RED') . $1 . color('RESET')/eg;
    return $buffer;
}

sub check_nagios {
    my $content = $ua->request($r)->{_content};
    # strip off the html
    $content =~ s/.*<\/?html>.*\n//g;

    # combine lines if there are more than 3 probes down on a system
    {
        my %counts;
        $counts{$_}++ for $content =~ /^(\S+)/mg;
        for(sort keys %counts) {
            next unless $counts{$_} > 3;
            my $count = $content =~ s/^($_)\b.*\n//mg;
            $content .= "There are $count $_ probes down.\n";
        }
    }
    
    # dont show ntp probes if there are more than 2 down
    if($content =~ s/\bntp\b/ntp/g > 2) {
        my $count = ($content =~ s/.*\bntp\b.*\n//g);
        $content .= "There are $count ntp probes down.\n";
    }

    # truncate the lines so they dont wrap
    $content =~ s/^(.{1,$width}).*$/$1/gm;
    output("$content\n") if $content;
}

sub check_irc {
    for(glob "$ENV{HOME}/.irssi/logs/*/*.log") {
        undef $/;
        open LOG, "<$_" or die "couldnt open $_: $!\n";
        $_ = <LOG>;
        close LOG;
        s/[\s\S]*\n--- Log closed.*\n//;
        s/[\s\S]*\n\d+:\d+\s+\*!\* \| Irssi:.*?Total of \d+ nicks.*\n//;
        s/.*\*!\* \|.*\n//g;
        s/^--- Day changed.*\n//mg;
        s/[\s\S]*\n\d\d:\d\d\s+\@?enyalios\s+\|.*\n//;
        output("$_\n") if $_;
    }
}

sub check_jabber {
    for(glob "$ENV{HOME}/.mcabber/histo/*") {
        my $name = $_;
        $name =~ s/^.*\/(.*)\@.*$/$1/;

        undef $/;
        open LOG, "<$_" or die "couldnt open $_: $!\n";
        $_ = <LOG>;
        close LOG;

        s/[\s\S]*\n(M?S|MI .* 000 You have joined as |MR .* 000 <$user> ).*\n//;
        s/^MI .* 000 .* has (left|joined)\n//mg;
        s/^M. /$name /mg;
        my $date = strftime "%Y%m%d", localtime;
        if($_ !~ /^cites-smg /) {
            output("$_\n") if $_;
        } else {
            for(split /\n/, $_) {
                output("$_\n") if /^cites-smg $date/;
            }
            output("\n") if /^cites-smg $date/m;
        }
    }
}

sub check_email {
    my $emails = join "", `imapls -n`;
    output("$emails\n") if $emails;
}

sub check_calendar {
    my $output = "Could not connect to the exchange calendar.\n\n";
    # we eval this so that errors connecting to exchange dont kill the whole script
    eval '$output = &exchange_cal()';
    #$output = &exchange_cal();
    output($output);
}

sub exchange_cal {

    # renew our kerberos ticket
    system(qw"kinit -R");
    my $output;
    my $now = strftime("%s", localtime);
    my $tz = "-06:00";
    my $start = strftime("%F", localtime) . 'T00:00:00' . $tz;
    my $end   = strftime("%F", localtime($now + 24*60*60*7)) . 'T00:00:00' . $tz;

    my $service = SOAP::Lite
    ->service("https://exchws.illinois.edu/ews/Services.wsdl")
    ->proxy("https://exchws.illinois.edu/ews/exchange.asmx")
    ->encodingStyle('')
    ->ns("http://schemas.microsoft.com/exchange/services/2006/types",'t')
    ->default_ns("http://schemas.microsoft.com/exchange/services/2006/messages");

    my $response = $service->call(
        SOAP::Data->name('FindItem')
        ->attr({'Traversal'=>'Shallow',
                'xmlns' => 'http://schemas.microsoft.com/exchange/services/2006/messages'
            }),
        SOAP::Header->name('RequestServerVersion')->prefix('t')->type('')
        ->attr({'Version' => 'Exchange2010_SP1'}),
        SOAP::Data->name('ItemShape' => \SOAP::Data->value(
            SOAP::Data->name('BaseShape')->value('IdOnly')
            ->prefix('t')
            ->type(''),
            SOAP::Data->name('AdditionalProperties' => \SOAP::Data->value(
                SOAP::Data->name('FieldURI')->prefix('t')
                ->attr({ 'FieldURI' => 'calendar:Start' }),
                SOAP::Data->name('FieldURI')->prefix('t')
                ->attr({ 'FieldURI' => 'calendar:End' }),
                SOAP::Data->name('FieldURI')->prefix('t')
                ->attr({ 'FieldURI' => 'item:Subject' }),
                SOAP::Data->name('FieldURI')->prefix('t')
                ->attr({ 'FieldURI' => 'calendar:Location' }),
            ))->prefix('t'),
    )),
    SOAP::Data->name('CalendarView')
    ->attr( { 'MaxEntriesReturned' => '10',
        'StartDate' => $start,
        'EndDate'   => $end,
    }),
    SOAP::Data->name('ParentFolderIds')->value(
        \SOAP::Data->name('DistinguishedFolderId')->attr({ 'Id' => 'calendar' })
    ->prefix('t')
    ->type('')
    ));

    my $num = 0;
    foreach ($response->valueof('//ResponseMessages/FindItemResponseMessage/RootFolder/Items/CalendarItem')){
        $output .= sprintf "%s - %s %-28s %s\n",
            strftime("%a %b %d %R", localtime str2time $_->{"Start"}),
            strftime("%R", localtime str2time $_->{"End"}),
            $_->{'Location'},
            $_->{'Subject'};
        $num++;
    }

    $output .= "\n" if $num;
    return $output;
}
