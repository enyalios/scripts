#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use Date::Parse; # from dev-perl/TimeDate
use IO::Socket::SSL; # from dev-perl/IO-Socket-SSL
use LWP::Simple; # from dev-perl/libwww-perl
use MIME::Base64; 
use MIME::Words qw(decode_mimewords); # from dev-perl/MIME-tools
use Mail::IMAPClient; # from dev-perl/Mail-IMAPClient
use POSIX;
use SOAP::Lite maptype=>{}; # from dev-perl/SOAP-Lite
use SOAP::Transport::HTTP; # from dev-perl/SOAP-Lite
use Term::ANSIColor;
use Term::Cap;
use Term::ReadKey; # from dev-perl/TermReadKey

# set up some variables
my $user = "guder";
my $delay = 0;
$delay = $ARGV[0] if(defined $ARGV[0] && $ARGV[0] =~ /\d+/);

my ($buffer, $width, $height);
$| = 1;

my $pass = get_password();

# make the cursor dissappear if we're a daemon
$SIG{INT} = sub { &fix_term && exit };
END { &fix_term }
sub fix_term { print "\e[?25h"; }
print "\e[?25l" if $delay;

# set up the request for getting monitoring info
my $ua = LWP::UserAgent->new;
my $r = HTTP::Request->new(GET => 'https://smgmon.cites.illinois.edu/nagios/cgi-bin/short-details.cgi');
my $auth = MIME::Base64::encode("$user:$pass");
$r->header(Authorization => "Basic $auth");

# open the imap connection that we'll be using
my $imap = &connect_to_imap();

while(1) {
    ($width, $height, undef, undef) = GetTerminalSize();
    $buffer = "";

    &check_nagios();
    &check_calendar();
    &check_email();
    &check_irc();
    &check_jabber();

    # bail if we're not a daemon, since we already printed everything
    last unless $delay;

    &clear_screen();
    $buffer = &get_header() . $buffer;
    $buffer = &truncate($buffer);
    $buffer = &colorize($buffer);
    print $buffer;
    sleep $delay;
}

sub output {
    return unless defined $_[0];
    print $_[0] and return unless $delay;
    # add newlines so that no lines wrap
    $_ = $_[0];
    1 while s/^(.{$width})(?!\n)/$1\n/m;
    $buffer .= $_;
}

sub get_password {
    print "$user\'s AD password: ";
    ReadMode('noecho');
    my $pw = ReadLine(0);
    ReadMode('normal');
    chomp $pw;
    print "\n";
    return $pw;
}

sub clear_screen {
    my $termios = POSIX::Termios->new;
    $termios->getattr;
    my $term = Term::Cap->Tgetent( { OSPEED => $termios->getospeed } );
    $term->Tputs('cl', 1, *STDOUT);
}

sub get_header {
    # generate a nice header like the one 'watch' prints
    my $lheader = "Every $delay.0s: $0";
    my $rheader = localtime;
    return $lheader . " " x ($width - length($rheader) - length($lheader)) . $rheader . "\n\n";
}

sub truncate {
    # truncate the buffer so it doesnt scroll off the screen
    my $buffer = $_[0];
    $buffer =~ s/^((?:.*\n){1,$height})[\s\S]*/$1/;
    $buffer =~ s/\n$//;
    return $buffer;
}

sub colorize {
    # color probes that arent ack'ed
    my $buffer = $_[0];
    $buffer =~ s/(.*     WARNING .*)/color('YELLOW') . $1 . color('RESET')/eg;
    $buffer =~ s/(.*     CRITICAL .*)/color('RED') . $1 . color('RESET')/eg;
    return $buffer;
}

sub check_nagios {
    my $content = $ua->request($r)->{_content};
    # strip off the html
    $content =~ s/.*<\/?html>.*\n//g;

    # combine lines if there are more than 3 probes down on a system
    {
        my %counts;
        $counts{$_}++ for $content =~ /^(\S+)/mg;
        for(sort keys %counts) {
            next unless $counts{$_} > 3;
            my $count = $content =~ s/^($_)\b.*\n//mg;
            $content .= "There are $count $_ probes down.\n";
        }
    }
    
    # dont show ntp probes if there are more than 2 down
    if($content =~ s/\bntp\b/ntp/g > 2) {
        my $count = ($content =~ s/.*\bntp\b.*\n//g);
        $content .= "There are $count ntp probes down.\n";
    }

    # truncate the lines so they dont wrap
    $content =~ s/^(.{1,$width}).*$/$1/gm;
    output("$content\n") if $content;
}

sub check_irc {
    for(glob "$ENV{HOME}/.irssi/logs/*/*.log") {
        undef $/;
        open LOG, "<$_" or die "couldnt open $_: $!\n";
        $_ = <LOG>;
        close LOG;
        s/[\s\S]*\n--- Log closed.*\n//;
        s/[\s\S]*\n\d+:\d+\s+\*!\* \| Irssi:.*?Total of \d+ nicks.*\n//;
        s/.*\*!\* \|.*\n//g;
        s/^--- Day changed.*\n//mg;
        s/[\s\S]*\n\d\d:\d\d\s+\@?enyalios\s+\|.*\n//;
        output("$_\n") if $_;
    }
}

sub check_jabber {
    for(glob "$ENV{HOME}/.mcabber/histo/*") {
        my $name = $_;
        $name =~ s/^.*\/(.*)\@.*$/$1/;

        undef $/;
        open LOG, "<$_" or die "couldnt open $_: $!\n";
        $_ = <LOG>;
        close LOG;

        s/[\s\S]*\n(M?S|MI .* 000 You have joined as |MR .* 000 <$user> ).*\n//;
        s/^MI .* 000 .* has (left|joined)\n//mg;
        s/^S[ON_] .* 000 .*\n//mg;
        s/^M. /$name /mg;
        my $date = strftime "%Y%m%d", localtime;
        if($_ !~ /^cites-smg /) {
            output("$_\n") if $_;
        } else {
            for(split /\n/, $_) {
                output("$_\n") if /^cites-smg $date/;
            }
            output("\n") if /^cites-smg $date/m;
        }
    }
}

sub check_calendar {
    my $output = "Could not connect to the exchange calendar.\n\n";
    # we eval this so that errors connecting to exchange dont kill the whole script
    eval '$output = &exchange_cal()';
    #$output = &exchange_cal();
    output($output);
}

sub exchange_cal {

    # renew our kerberos ticket
    system(qw"kinit -R");
    my $output;
    my $now = strftime("%s", localtime);
    my $tz = "-06:00";
    # this craziness is all to make it look at the next 2 business days
    my $range = 2;
    my $day_of_week = strftime("%w", localtime);
    if($day_of_week >= 4) {
        $range = 4;
    } elsif($day_of_week == 0) {
        $range = 3;
    }
    my $start = strftime("%F", localtime) . 'T00:00:00' . $tz;
    my $end   = strftime("%F", localtime($now + 24*60*60*$range)) . 'T00:00:00' . $tz;

    my $service = SOAP::Lite
    ->service("https://exchws.illinois.edu/ews/Services.wsdl")
    ->proxy("https://exchws.illinois.edu/ews/exchange.asmx")
    ->encodingStyle('')
    ->ns("http://schemas.microsoft.com/exchange/services/2006/types",'t')
    ->default_ns("http://schemas.microsoft.com/exchange/services/2006/messages");

    my $response = $service->call(
        SOAP::Data->name('FindItem')
        ->attr({'Traversal'=>'Shallow',
                'xmlns' => 'http://schemas.microsoft.com/exchange/services/2006/messages'
            }),
        SOAP::Header->name('RequestServerVersion')->prefix('t')->type('')
        ->attr({'Version' => 'Exchange2010_SP1'}),
        SOAP::Data->name('ItemShape' => \SOAP::Data->value(
            SOAP::Data->name('BaseShape')->value('IdOnly')
            ->prefix('t')
            ->type(''),
            SOAP::Data->name('AdditionalProperties' => \SOAP::Data->value(
                SOAP::Data->name('FieldURI')->prefix('t')
                ->attr({ 'FieldURI' => 'calendar:Start' }),
                SOAP::Data->name('FieldURI')->prefix('t')
                ->attr({ 'FieldURI' => 'calendar:End' }),
                SOAP::Data->name('FieldURI')->prefix('t')
                ->attr({ 'FieldURI' => 'item:Subject' }),
                SOAP::Data->name('FieldURI')->prefix('t')
                ->attr({ 'FieldURI' => 'calendar:Location' }),
            ))->prefix('t'),
    )),
    SOAP::Data->name('CalendarView')
    ->attr( { 'MaxEntriesReturned' => '10',
        'StartDate' => $start,
        'EndDate'   => $end,
    }),
    SOAP::Data->name('ParentFolderIds')->value(
        \SOAP::Data->name('DistinguishedFolderId')->attr({ 'Id' => 'calendar' })
    ->prefix('t')
    ->type('')
    ));

    my $num = 0;
    foreach ($response->valueof('//ResponseMessages/FindItemResponseMessage/RootFolder/Items/CalendarItem')){
        $output .= sprintf "%s - %s %-28s %s\n",
            strftime("%a %b %d %R", localtime str2time $_->{"Start"}),
            strftime("%R", localtime str2time $_->{"End"}),
            $_->{'Location'},
            $_->{'Subject'};
        $num++;
    }

    $output .= "\n" if $num;
    return $output;
}

sub check_email {
    my $now = strftime "%s", localtime;
    # figure out what we are searching for
    my @search = ("UNSEEN");
    # @search = ("ALL");
    # @search = ("FLAGGED");
    # @search = ('OR', 'OR', 'TO', $imap->Quote($opts{s}), 
    #     'FROM', $imap->Quote($opts{s}),
    #     'SUBJECT', $imap->Quote($opts{s})) if $opts{s};

    # get a list of all folders
    my @folders = $imap->folders();
    for(@folders) {
        my @emails;
        # skip some special cases
        next if /^\[Gmail\]\/(All Mail|Spam|Starred|Sent Mail|Important)$/;
        # open the folder read-only
        $imap->examine($_);
        # list unread messages
        my $msgs = $imap->search(@search);
        next unless $msgs && @{$msgs};
        # print out a folder header
        output("* $_(" . scalar @{$msgs} . ")\n");
        my $headers = $imap->parse_headers($msgs, "Date", "From", "Subject");
        my $flags = $imap->flags($msgs);
        for(keys %{$headers}) {
            my $epoch = &get_epoch($headers->{$_}->{Date}->[0]);
            push @emails, {
                epoch => $epoch,
                date => &format_date($epoch, $now),
                from => &format_from($headers->{$_}->{From}->[0]),
                subject => &format_subject($headers->{$_}->{Subject}->[0]),
                flags => &format_flags($flags->{$_}),
            }
        }

        # print everything out nicely sorted by date
        for(sort { $a->{epoch} <=> $b->{epoch} } @emails) {
            output(sprintf "  %-2s %-11s  %-23.23s  %-s\n", $_->{flags}, $_->{date}, $_->{from}, $_->{subject});
        }
        output("\n") if @emails;

    }
}

sub connect_to_imap {
    # grab authentication info
    my ($host, $user, $pass) = ("imap.illinois.edu:993", "guder\@illinois.edu", $pass);

    # open an ssl socket since gmail is over ssl
    my $sock = IO::Socket::SSL->new(
        SSL_verify_mode => SSL_VERIFY_PEER,
        SSL_ca_path => '/etc/ssl/certs',
        PeerHost => $host) or die "socket(): $@";
    my $greeting = <$sock>;
    die "problems logging in: $greeting" unless $greeting =~ ' OK ';

    # use the socket and our credentials to open an imap connection
    my $imap = Mail::IMAPClient->new(
        RawSocket => $sock,
        User      => $user,
        Password  => $pass,
    ) or die "Cannot imap: $@";

    # connect and login
    $imap->State($imap->Connected);
    $imap->login() or die "cannot login: $@\n";
    print "could not authenticate\n" unless $imap->IsAuthenticated();
    return $imap;
}

sub get_epoch {
    my $epoch = str2time $_[0];
    $epoch ||= 0;
    return $epoch;
}

sub format_date {
    # format a date nicely
    my $date;
    my $epoch = $_[0];
    my $now = $_[1];
    if(($now - $epoch) < 60*60) {
        my $amount = ($now - $epoch) / 60;
        $date = sprintf "%2d min%s ago", $amount, $amount>=2?"s":" ";
    } elsif(($now - $epoch) < 60*60*24) {
        my $amount = ($now - $epoch) / 60 / 60;
        $date = sprintf "%2d hr%s  ago", $amount, $amount>=2?"s":" ";
    } elsif(($now - $epoch) < 60*60*24*7) {
        my $amount = ($now - $epoch) / 60 / 60 / 24;
        $date = sprintf "%2d day%s ago", $amount, $amount>=2?"s":" ";
    } else {
        $date = strftime "%b %d %Y", localtime $epoch;
    }
    return $date;
}

sub format_from {
    # format a from field nicely
    my $from = $_[0] || "";
    $from =~ s/^ *(?:"?(.+?)"? *<.+>|<?(.+?)>?)$/$+/i;
    $from =~ s/\n//g;
    $from = decode_mimewords($from) if($from =~ /^=\?(ISO-8859-1|koi8-r|utf-8|windows-1252)\?/i);
    return $from;
}

sub format_subject {
    # format a subject field nicely
    my $subject = $_[0] || "";
    $subject =~ s/\n//g;
    $subject =~ s/\t+/ /g;
    $subject = decode_mimewords($subject) if($subject =~ /^=\?(ISO-8859-1|koi8-r|utf-8|windows-1252)\?/i);
    substr($subject, $width - 46) = "..." if($width && length $subject > $width - 43);
    return $subject;
}

sub format_flags {
    # get info on the message flags
    my %flags;
    # we're passed an array of flags, stuff it into a hash for easy querying
    $flags{$_} = 1 for @{$_[0]};
    my $flag_string = sprintf "%s%s",
        exists($flags{"\\Seen"})?" ":"N",
        exists($flags{"\\Flagged"})?"!":" ";
    return $flag_string;
}
