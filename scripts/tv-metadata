#!/usr/bin/perl

use strict;
use warnings;
use LWP::Simple;
use DBI;

my $show = "spin city";

sub PrintEpisode {

  my ($ref) = @_;

  print "Title: $ref->{title}\n";
  print "Year: $ref->{year}\n";
  print "Director: $ref->{director}\n";
  print "Rating: $ref->{rating}\n";
  print "Plot: $ref->{plot}\n";
  print "-----------------------\n";

}

sub GetData {

  my ($title) = @_;

  (my $show_url, $title ) = get("http://www.tv.com/search.php?stype=all&qs=$title") =~ /<a class="f-bold f-C30" href="(.*summary\.html).*?">(.*?)<\/a>/;

  die "could not find any show by that name!\n" unless $show_url;
  $show_url =~ s/summary\.html$/episode_guide.html?printable=1/;
  #print "\$show_url: $show_url\n";

  my @list;

  #the first time in the list we return is the nice title of the show.
  push @list, $title;

  my $page = get $show_url;

  foreach( split(/<div class="pl-5 pr-5">/,$page)){
    #print $_;

    my %episode;

    $_ =~ m|<h1><a.*>\s+\d+\.\s+(.*)\s+</a> </h1>|;
    #print "$1\n";
    $episode{title} = $1;

    $_ =~ m|First aired:</span>\s*\d+/\d+/(\d+)<br/>|;
    #print "$1\n";
    $episode{year} = $1;

    $_ =~ m|Director:</span>\s+<a href=".*"> (.*)</a>|;
    #print "$1\n";
    $episode{director} = $1;

    $_ =~ m|Global rating:</span>\s+<a href.*>(\d+\.\d+)</a>|;
    #print "$1\n";
    $episode{rating} = $1;

    $_ =~ m|</div>\s+<p>(.*)</p>\s+</div>|;
    #print "$1\n";
    $episode{plot} = $1;

    #print "------------------------------\n";

    #  PrintEpisode(\%episode);
    push @list, \%episode if $episode{title};
  }
  return @list;
}

#main---------------------------------------------

#Database
my $database = "mythconverg";
my $hostname = "mythtv";
my $user = "mythtv";
my $password = "mythtv";

#get the data from tv.com
my @episodes = GetData($show);

# the first value in the array is not an episode, but the show title
# fromatted nicely.
$show = shift @episodes;



sub UpdateShow {

  my @shows = @_;

  #Database
  my $dsn = "DBI:mysql:database=$database;host=$hostname";
  my $dbh  = DBI->connect($dsn, $user, $password);
  my $rs;

  my %duplicateEpisodeCount;

  foreach my $ref ( @shows){

    # This count lets us know how many episodes of any given title
    # we have processed. Shows are listed cronologially we rely on this
    # to sort out problems with 1 show having 2 episodes that have the exact
    # same name connical name. 
    $duplicateEpisodeCount{$ref->{title}}++;

    # these guys control the changes that are made to the title to try and
    # and find a file name match.
    my $modifyTitleCounter = 0;
    my $modifyTitleCounterMax = 4;

    # this holds the return values from our sql queries.
    my $listRef;

    do{

      #this part of the loop formats the title correctly for this iteration
      my $workingTitle = $ref->{title};
      my $workingShow = $show;
      # always remove these evil chars, they will never be in file names
      $workingTitle =~ s/[:\*\?"<>\\\/|]//g;
      $workingTitle =~ s/&/and/g;

      $workingShow =~ s/[:\*\?"<>\\\/|]//g;
      $workingShow =~ s/&/and/g;

      # The order of things is important here! Conisder the example
      # Spin City - 425 - Goodbye 1.avi
      # Spin City - 426 - Goodbye 2.avi
      # both fail the first match cause tv.com uses (1) and (2)
      # both match exactly 1 when we remove parens, looking stops here
      # but if we continues both would match if we removes the numbers, which
      # is what removing parentheical referances, step 2, does.
      # Step 1 must come before step 2!

      # step 3 for paul's stuff is roughly independent and can be placed
      # before or after steps 1 and 2.


      # On 1 try title without parens
      if( $modifyTitleCounter == 1 ){
	$workingTitle =~ s/[\(\)]//g;
      }
      # On 2 try title with parentheitcal phrases removed
      elsif( $modifyTitleCounter == 2 ){
	$workingTitle =~ s/\s*\(.*\)\s*//g;
      }
      # on 3 try paul's filename format
      elsif( $modifyTitleCounter == 3 ){
	$workingTitle = lc($workingTitle);
	$workingTitle =~ s/- //g;
	$workingTitle =~ s/ /_/g;
	$workingTitle =~ s/\W//g;

	$workingShow = lc($workingShow);
	$workingShow =~ s/- //g;
	$workingShow =~ s/ /_/g;
	$workingShow =~ s/\W//g;
      }

      # now get all the id's for episodes that match the current formatting of the title
      $rs = $dbh->prepare(qq{SELECT intid FROM videometadata WHERE filename like "%$workingShow%$workingTitle%" ORDER BY filename ASC});
      # we depend of sorting by filename to return episodes in cronolical order.

      $rs->execute();
      $listRef = $rs->fetchall_arrayref();

      $modifyTitleCounter++;

      # if we got any results or if we have tired all vereations then stop
    } until( @{$listRef} > 0 || $modifyTitleCounter > $modifyTitleCounterMax);

    my $intid;

    #if we got results
    if( @{$listRef} > 0){

      # This little expression does the figuring for the duplicate episode tile
      # situation. It also handles single titles gracefully. We have a count of
      # how many episodes with this cannonical title we have seen so far. We
      # also have a list of all the episodes with this cannonical title in
      # cronolical order. Use the Nth item in the list where N = the count in 
      # the hash. -1 corrects for array position from the count.

      # This only works because evrything is in cronolical order
      $intid = @{@{$listRef}[$duplicateEpisodeCount{$ref->{title}}-1]}[0];

      #we need to make the plot SQL safe before we insert it.
      $ref->{plot} =~ s/\n//g;
      $ref->{plot} =~ s/\r//g;
      $ref->{plot} =~ s/"/\\"/g;
      $ref->{plot} =~ s/'/\\'/g;
      $ref->{plot} =~ s/\x92/\\'/g;
      $ref->{plot} =~ s/\x93/\\"/g;
      $ref->{plot} =~ s/\x94/\\"/g;
      $ref->{plot} =~ s/\x96/-/g;


      $rs = $dbh->prepare(qq{UPDATE videometadata SET director = "$ref->{director}", plot = "$ref->{plot}", userrating = "$ref->{rating}", year = "$ref->{year}" WHERE intid = "$intid"});
      $rs->execute();
      $rs->finish();

    }
    else{
      print "Could not find match for $show $ref->{title}\n";
    }
  }

  $rs->finish();
  $dbh->disconnect();
}
