#!/usr/bin/perl

use strict;
use warnings;
use LWP::Simple;
use DBI;
use POSIX qw(ceil floor);

# Static variables
my $imagePath = "/home/mythuser/.mythtv/MythVideo";
my $imageTime = "1:00";


# Database
my $database = "mythconverg";
my $hostname = "mythtv";
my $user = "mythtv";
my $password = "mythtv";

# we don't handle arguments yet so for now use this
my $show = "spin city";
my $override = 1;


# mostly here for debuggin, not really used.
sub PrintEpisode {

  my ($ref) = @_;

  print "Title: $ref->{title}\n";
  print "Number: $ref->{number}\n";
  print "Year: $ref->{year}\n";
  print "Director: $ref->{director}\n";
  print "Rating: $ref->{rating}\n";
  print "Plot: $ref->{plot}\n";
  print "-----------------------\n";

}

# this takes in a title to search for on tv.com and handles all the parsing
sub GetData {

  my ($title) = @_;

  (my $show_url, $title ) = get("http://www.tv.com/search.php?stype=all&qs=$title") =~ /<a class="f-bold f-C30" href="(.*summary\.html).*?">(.*?)<\/a>/;

  die "could not find any show by that name!\n" unless $show_url;
  $show_url =~ s/summary\.html$/episode_guide.html?printable=1/;
  #print "\$show_url: $show_url\n";

  my @list;

  # the first item in the list we return is the nice title of the show.
  push @list, $title;

  my $page = get $show_url;

  foreach( split(/<div class="pl-5 pr-5">/,$page)){
    #print $_;

    my %episode;

    $_ =~ m|<h1><a.*>\s+(\d+)\.\s+(.*)\s+</a> </h1>|;
    #print "$1\n";
    $episode{number} = $1;
    $episode{title} = $2;

    $_ =~ m|First aired:</span>\s*\d+/\d+/(\d+)<br/>|;
    #print "$1\n";
    $episode{year} = $1;

    $_ =~ m|Director:</span>\s+<a href=".*"> (.*)</a>|;
    #print "$1\n";
    $episode{director} = $1;

    $_ =~ m|Global rating:</span>\s+<a href.*>(\d+\.\d+)</a>|;
    #print "$1\n";
    $episode{rating} = $1;

    $_ =~ m|</div>\s+<p>(.*)</p>\s+</div>|;
    #print "$1\n";
    $episode{plot} = $1;

    #print "------------------------------\n";

    #  PrintEpisode(\%episode);
    push @list, \%episode if $episode{title};
  }
  return @list;
}


# this takes the list produced above and matches it to filenames that
# appear in the mythtv database. it does episode title matching to figure
# things out, but handles duplicate episode titles correctly.
sub UpdateShow {

  my $show = shift @_;
  my @shows = @_;

  #Database
  my $dsn = "DBI:mysql:database=$database;host=$hostname";
  my $dbh  = DBI->connect($dsn, $user, $password);
  my $rs;

  my %duplicateEpisodeCount;

  foreach my $ref ( @shows){

    # This count lets us know how many episodes of any given title
    # we have processed. Shows are listed chronologically we rely on this
    # to sort out problems with 1 show having 2 episodes that have the exact
    # same canonical name. 
    $duplicateEpisodeCount{$ref->{title}}++;

    # these guys control the changes that are made to the title to try and
    # and find a file name match.
    my $modifyTitleCounter = 0;
    my $modifyTitleCounterMax = 4;

    # this holds the return values from our sql queries.
    my $listRef;

    do{

      #this part of the loop formats the title correctly for this iteration
      my $workingTitle = $ref->{title};
      my $workingShow = $show;
      # always remove these evil chars, they will never be in file names
      $workingTitle =~ s/[:\*\?"<>\\\/|]//g;
      $workingTitle =~ s/&/and/g;

      $workingShow =~ s/[:\*\?"<>\\\/|]//g;
      $workingShow =~ s/&/and/g;

      # The order of things is important here! Consider the example
      # Spin City - 425 - Goodbye 1.avi
      # Spin City - 426 - Goodbye 2.avi
      # both fail the first match cause tv.com uses (1) and (2)
      # both match exactly 1 when we remove parens, looking stops here
      # but if we continues both would match if we removes the numbers, which
      # is what removing parenthetical references, step 2, does.
      # Step 1 must come before step 2!

      # step 3 for paul's stuff is roughly independent and can be placed
      # before or after steps 1 and 2.

      # On 0 try the title as is, with evil chars ^above^ removed of course.
      # On 1 try title without parens
      if( $modifyTitleCounter == 1 ){
        $workingTitle =~ s/[\(\)]//g;
      }
      # On 2 try title with parenthetical phrases removed
      elsif( $modifyTitleCounter == 2 ){
        $workingTitle =~ s/\s*\(.*?\)\s*//g;
      }
      # on 3 try paul's filename format
      elsif( $modifyTitleCounter == 3 ){
        $workingTitle = lc($workingTitle);
        $workingTitle =~ s/ - /_/g;
        $workingTitle =~ s/ /_/g;
        $workingTitle =~ s/\W//g;

        $workingShow = lc($workingShow);
        $workingShow =~ s/ - /_/g;
        $workingShow =~ s/ /_/g;
        $workingShow =~ s/\W//g;
      }

      # now get all the id's for episodes that match the current formatting
      # of the title
      $rs = $dbh->prepare(qq{SELECT intid, title, inetref, filename FROM videometadata WHERE filename like "%$workingShow%$workingTitle%" ORDER BY filename ASC});
      # we depend of sorting by filename to return episodes in cronolical order.

      $rs->execute();
      $listRef = $rs->fetchall_arrayref();

      $modifyTitleCounter++;

      # if we got any results or if we have tired all variations then stop
    } until( @{$listRef} > 0 || $modifyTitleCounter > $modifyTitleCounterMax);

    #if we got results
    if( @{$listRef} > 0){

      # This little expression does the figuring for the duplicate episode
      # title situation. It also handles single titles gracefully. We have a
      # count of how many episodes with this canonical title we have seen so
      # far. We also have a list of all the episodes with this cannonical title
      # in chronological order. Use the Nth item in the list where N = the
      # count in the hash. -1 corrects for array position from the count.

      # This only works because everything is in chronological order!
      my ($intid, $niceTitle, $inetref, $filename) = @{@{$listRef}[$duplicateEpisodeCount{$ref->{title}}-1]};

      if( $inetref == 0 || $override ){

        #we need to make the plot SQL safe before we insert it.
        $ref->{plot} =~ s/\n//g;
        $ref->{plot} =~ s/\r//g;
        $ref->{plot} =~ s/"/\\"/g;
        $ref->{plot} =~ s/'/\\'/g;
        $ref->{plot} =~ s/\x92/\\'/g;
        $ref->{plot} =~ s/\x93/\\"/g;
        $ref->{plot} =~ s/\x94/\\"/g;
        $ref->{plot} =~ s/\x96/-/g;

        # some shows may not have a number for some reason, if they don't
        # we'll use NAN (not a number) for the inetref because we need
        # something non zero. This will als fix it if the number is zero.
        $ref->{number} = "NAN" unless $ref->{number};

        # possibly optional, this function gets a screen capture
        # from the episode and places in the right place on the filesystem.
        # it returns the full path to the image.

        # currently using midentify to get the real pixle widths isn't done
        # so we use some sane defaults, but this will need to be fixed.
        my $image = GrabImage($show,$filename,480,360);

        $rs = $dbh->prepare(qq{UPDATE videometadata SET director = "$ref->{director}", plot = "$ref->{plot}", userrating = "$ref->{rating}", year = "$ref->{year}", inetref = "$ref->{number}", coverfile = "$image" WHERE intid = "$intid"});

        print "Updated $niceTitle\n" if $rs->execute();
      }
    }
    else{
      print "Could not find match for $show $ref->{title}\n";
    }
  }

  $dbh->disconnect();
}

# This function will grab an image if needed for the given episode.
# It will return the filename.
sub GrabImage {

  my ( $show, $filename, $width, $height ) = @_;

  my ($seasonEpNumber) = $filename =~ m/(?: - |_)(\d+)\1/;

  # simplify the show title
  $show = lc($show);
  $show =~ s/\W//g;

  # make the directory for this show if we need to.
  mkdir "$imagePath/$show" unless -e "$imagePath/$show";
  die "$imagePath/$show is not a directory\n" unless -d "$imagePath/$show";

  # if the image for this show does not exist, make it
  unless( -e "$imagePath/$show/$seasonEpNumber.png" || -e "$imagePath/$show/$seasonEpNumber.jpg" ){

    # get the right aspect ratio regardless of the input aspect ratio
    if( $width > $height/0.68289 ){
      $width = ceil($height*0.68289);
    }
    else{
      $height = ceil($width/0.68289);
    }

    # make mplayer do all the work for us.
    # TODO: Right now it drops the images in the current directory, it would
    # be good to put them in /tmp or something.
    system("mplayer -vf crop=$width:$height -nosound -vo png:z=9 -ss $imageTime -frames 5 \"$filename\"");

    # Take the last frame and use it as the image for this show.
    rename "00000005.png" "$imagePath/$show/$seasonEpNumber.png";

    # clean up the current directory.
    unlink <0000000*.png>;
  }

  # returning the full path to insert in the database seems to be the best
  # way to avoid doing work twice, while still compartmentizing things.
  return "$imagePath/$show/$seasonEpNumber.png";
}



# MAIN --------------------------------------------------

# get the data from tv.com
my @episodes = GetData($show);

# both functions use the first position the the list to hold the
# show's name.

UpdateShow(@episodes);

# vim:sw=2:ts=8
