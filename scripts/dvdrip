#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Declare;

# declaring variables and setting up the defaults
$main::VERSION  = "0.10";
$ENV{MPLAYER_VERBOSE} = "-2";

# 'our' lets Getopt::Declare look at these, while 'my' would not
my $suffix = "-$$";
my $prefix = ".";
our $aid         = "";
our $bitrate     = "";
our $crop        = "";
our $size        = "700";
our $dvd_device  = "";
our $sid         = "";
our $outfile     = "movie${suffix}.avi";
our $deint       = "";
our $pretend     = "";
our $noise       = "";
our $width       = "640";
our $keep        = "0";

# Getopt::Declare parameter specifications
# read 'perldoc Getopt::Declare'
# but, in short:
# [strict] makes it die when there's an error
# <n:+i> means match positive integer, store in $n for block
# { block } is executed when an argument is matched
# [ditto] means same as previous argument (and uses same block)
# --switch param \tdescription (need tab immediately before description)
# [required] means this arg or a [ditto] of this arg must be present
# [mutex] means at most one of these args
# Getopt::Declare automatically generates --help output
my $specification = q(
    [pvtype: cr /\d+:\d+:\d+:\d+:?/] # WTF!?! the help message just hangs if
                                     # the regex ends with a '+' so i tacked 
                                     # on a ':?' for no reason
    [mutex: -s --size -b --bitrate]

    -a <n:+i>            \taid number
                           { $::aid = "-aid $n"; }
    --aid <n:+i>         \t[ditto]

    -b <n:+i>            \tbitrate in kbits [required]
                           { $::bitrate = $n;
                             $::size = ""; }
    --bitrate <n:+i>     \t[ditto]

    -c [<region:cr>]     \tcrop borders (omit region to auto-detect)
                           { $::crop = "auto"; 
                             $::crop = $region if $region; }
    --crop [<region:cr>] \t[ditto]

    -d <path>            \tdvd device (default: /dev/dvd)
                           { $::dvd_device = "-dvd-device $path"; }
    --dvd-device <path>  \t[ditto]

    -k                   \tkeep temp files when finished
                           { $::keep = 1; }
    --keep               \t[ditto]

    -l                   \tdeinterlace video
                           { # maybe switch to pullup,softskip
                             # will prob need -ofps 24000/1001 too
                             $::deint = "lavcdeint,"; }
    --deinterlace        \t[ditto]

    -n                   \tdenoise video
                           { $::noise = "hqdn3d,"; }
    --denoise            \t[ditto]

    -o <file:of>         \twrite movie to <file> (default: movie-<pid>.mkv)
                           { $::outfile = $file; }
    --outfile <file:of>  \t[ditto]

    -p                   \tpretend (print out commands, but do not run them)
                           { $::pretend = 1; }
    --pretend            \t[ditto]

    -s <n:+i>            \ttarget filesize in megabytes [required]
                           { $::size = $n; }
    --size <n:+i>        \t[ditto]

    -S <n:+i>            \tsubtitle id number
                           { $::sid = "-sid ".$n; }
    --sid <n:+i>         \t[ditto]

    -w <n:+i>            \tvideo width (default: 640)
                           { # round width to nearest multiple of 16 to make 
                             # codecs more efficient
                             $::width = 16 * int(($n + 8)/16); }
    --width <n:+i>       \t[ditto]

    -i                   \t(deprecated, do not use)
                           { print "The '-i' and '-t' options are deprecated, ", 
                             "please look at the help output.\n";
                             exit 1; }
    --infile             \t[ditto]
    -t                   \t[ditto]
    --title              \t[ditto]
    );

# put tabs in $specification so Getopt::Declare doesn't complain
$specification =~ s/\\t/\t/g;

# $args is not used again--everything was done in blocks above
my $args = Getopt::Declare->new($specification);
exit(1) unless ($args);

# a nice function to either run or simply print system calls
sub my_system {
    $_[0] =~ s/[\n ]+/ /gm;
    if($pretend) {
        print "$_[0]\n";
    } else {
        system $_[0];
        if($? == -1) {
            die "Failed to execute command: $_[0]\n";
        } elsif($? >> 8 != 0) {
            die "Command returned with error code: ", $? >> 8, ": $_[0]\n";
        }
    }
}

sub print_options {
    print "# infiles    = @ARGV\n" if @ARGV;
    print "# outfile    = $outfile\n";
    print "# bitrate    = $bitrate\n" if $bitrate;
    print "# size       = $size\n" if $size;
    print "# width      = $width\n";
    print "# crop       = $crop\n" if $crop;
    print "# dvd-device = $dvd_device\n" if $dvd_device;
    print "# aid        = $aid\n" if $aid;
    print "# sid        = $sid\n" if $sid;
    print "# deinterlacing\n" if $deint;
    print "# denoising\n" if $noise;
    print "# pretend rip\n" if $pretend;
    print "\n";

    if (! $pretend) {
        local $| = 1; #autoflush on for this block
        print "encoding in ";
        for (reverse 1 .. 5) {
            print "$_ ";
            sleep(1);
        }
        print "\n\n";
    }
}

sub get_crop {
    # this part is sorta crazy.  we want to auto-detect the crop region so
    # we spawn mplayer telling it to cropdetect, but to step thru the video
    # 60 seconds at a time but only do a max of 60 frames.  we also tell 
    # it not to show audio or video here since this is just a command line
    # script.  finally we grap the 'crop=...' part from the last line that
    # starts with 'crop area:' since this is the region that mplayer decided
    # is best.
    if($crop eq "auto") {
        print "### Calculating crop region...\n";
        $_ = (grep { /^crop area:/ } `mplayer $dvd_device @ARGV -vo null \\
            -ao null -vf cropdetect=24:4 -sstep 60 -frames 60 2>/dev/null`)[-1];
        $crop = (/-vf (crop=[\d:]+)/)[0] . ",";
    } elsif($crop) {
        $crop = "crop=$crop,";
    }
}

sub audio_pass {
    print "### Encoding audio...\n";
    # we pass the audio data thru a fifo since mplayer cant encode oggs nativly
    my_system("mkfifo $prefix/pipe${suffix}");
    my_system("oggenc -o $prefix/audio${suffix}.ogg -b 96 $prefix/pipe${suffix} & 
        mplayer -vo null -vc dummy -ao pcm:file=$prefix/pipe${suffix} @ARGV
        $aid $dvd_device 2>/dev/null");

    # here we have to calculate the video bitrate if they just gave us a
    # target file size.  first we find the length and size of the audio track.
    # then we find out how much space we have left after subtracting the audio
    # size and container overhead from the target file size.  this crazy
    # calculation gives us or needed bitrate which we then round down to an
    # integer so mencoder doesnt barf.
    if(!$bitrate) {
        if($pretend) {
            # some crazy commands to dynamically determine the video bitrate
            # if we are doing a 'pretend'
            print "\n### Determining video bitrate...\n";
            print "video_bitrate=\$(echo \"($size*1024*1024*.995 - \$(ls -l ", 
            "$prefix/audio${suffix}.ogg | awk '{print \$5}')) / \$(mplayer -frames", 
            "0 -identify -vo null -ao null $prefix/audio${suffix}.ogg 2>/dev/null ",
            "| sed -ne 's/^ID_LENGTH=//p') / 1000 * 8\" | bc -l | sed -e ", 
            "'s/\\..*//')\n";
            $bitrate = "\${video_bitrate}" unless $bitrate;

        } else {
            my $alength = (map { (/^ID_LENGTH=([\d.]+)$/)[0] } 
                `mplayer -v -frames 0 -identify -vo null -ao null \\
                $prefix/audio${suffix}.ogg 2>/dev/null`)[0];
            my $asize = -s "$prefix/audio${suffix}.ogg";
            die "Improper audio length: $alength seconds\n" unless $alength > 0;
            die "Improper audio size: $asize bytes\n" unless $asize > 0;
            $bitrate = int(($size*1024*1024*.995 - $asize)/$alength/1000*8);
            print "# bitrate    = $bitrate\n";
        }
    }
}

sub video1_pass {
    print "\n### Encoding first pass...\n";
    my_system("mencoder @ARGV -o /dev/null 
        -passlogfile $prefix/divx2pass${suffix}.log -oac copy -ovc x264 -x264encopts 
        pass=1:bitrate=${bitrate}:turbo=1 -vf ${deint}${crop}${noise}scale=$width:-10 
        -zoom $dvd_device $sid -msglevel avsync=5 2>/dev/null");
}

sub video2_pass {
    print "\n### Encoding second pass...\n";
    my_system("mencoder @ARGV -o $prefix/video${suffix}.avi 
        -passlogfile $prefix/divx2pass${suffix}.log -oac copy -ovc x264 -x264encopts 
        pass=2:bitrate=${bitrate} -vf ${deint}${crop}${noise}scale=$width:-10 
        -zoom $dvd_device $sid -msglevel avsync=5 2>/dev/null");
}

sub mux_pass {
    print "\n### Muxing audio and video...\n";
    my_system("mkvmerge --engage allow_avc_in_vfw_mode --default-language 
        eng -o $outfile -A $prefix/video${suffix}.avi $prefix/audio${suffix}.ogg");
}

sub rm_tmp {
    return if $pretend;
    # remove the temp files unless the user told us not too or unless the final 
    # file size is off by more than 2 percent
    my $final_size = -s $outfile;
    my $diff = ($final_size/1024/1024 - $size) / $size * 100;
    if($diff >= 2 || $diff <=-2) {
        print "Final file size off by more than 2%, keeping temp files\n";
        $keep = 1;
    }
    unless($keep) { 
        unlink "$prefix/pipe${suffix}", "$prefix/audio${suffix}.ogg", 
        "$prefix/divx2pass${suffix}.log", "$prefix/video${suffix}.avi";
    }
}

get_crop();
print_options();
audio_pass();
video1_pass();
video2_pass();
mux_pass();
rm_tmp();

=for comment
    
TODO:

do some testing on the new deinterlacing method
do some testing on the new denoising method
test to make sure that remaining command line args after parsing switches are
    files or dvd tracks
fix calls to system so that they do not use the shell
    this will make the script deal with spaces and other shell metachars better
    this will be non-trivial since i use the shell to pipe mplayer audio to oggenc
switch to Getopt::Long so i have more control over the help message
add a switch for setting the directory for the temp files
