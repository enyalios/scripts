#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Declare;

# declaring variables and setting up the defaults
$main::VERSION  = "0.03";
$ENV{MPLAYER_VERBOSE} = "-2";

# 'our' lets Getopt::Declare look at these, while 'my' would not
my $suffix = "-$$";
my $prefix = ".";
our $aid         = "-aid 128";
our $bitrate     = "";
our $crop        = "";
our $size        = "700";
our $dvd_device  = "";
our $sid         = "";
our $outfile     = "movie${suffix}.avi";
our $infile      = "dvd://1";
our $deint       = "";
our $pretend     = "";
our $noise       = "";
our $width       = "640";
our $nice        = "10";

# Getopt::Declare parameter specifications
# read 'perldoc Getopt::Declare'
# but, in short:
# [strict] makes it die when there's an error
# <n:+i> means match positive integer, store in $n for block
# { block } is executed when an argument is matched
# [ditto] means same as previous argument (and uses same block)
# --switch param \tdescription (need tab immediately before description)
# [required] means this arg or a [ditto] of this arg must be present
# [mutex] means at most one of these args
# Getopt::Declare automatically generates --help output
my $specification = q(
    [strict]
    [pvtype: cr /\d+:\d+:\d+:\d+:?/] # WTF!?! the help message just hangs if
                                     # the regex ends with a '+' so i tacked 
                                     # on a ':?' for no reason
    [mutex: -s --size -b --bitrate]
    [mutex: -t --title -i --infile]

    -a <n:+i>            \taid number (default: 128)
                           { $::aid = "-aid $n"; }
    --aid <n:+i>         \t[ditto]

    -b <n:+i>            \tbitrate in kbits [required]
                           { $::bitrate = $n;
                             $::size = ""; }
    --bitrate <n:+i>     \t[ditto]

    -c [<region:cr>]     \tcrop borders (omit region to auto-detect)
                           { $::crop = "auto"; 
                             $::crop = $region if $region; }
    --crop [<region:cr>] \t[ditto]

    -d <path>            \tdvd device (default: /dev/dvd)
                           { $::dvd_device = "-dvd-device $path"; }
    --dvd-device <path>  \t[ditto]

    -e <n:i>             \tnice level (default: 10) (note that nice levels 
                                below 0 may require special priviliges)
                           { $::nice = $n; }
    --nice <n:i>         \t[ditto]

    -i <file:if>         \tinput file (defaults to dvd)
                           { $::infile = "\"$file\"";
                             $::aid = ""; }
    --infile <file:if>   \t[ditto]

    -l                   \tdeinterlace video
                           { # maybe switch to pullup,softskip
                             # will prob need -ofps 24000/1001 too
                             $::deint = "lavcdeint,"; }
    --deinterlace        \t[ditto]

    -n                   \tdenoise video
                           { $::noise = "hqdn3d,"; }
    --denoise            \t[ditto]

    -o <file:of>         \twrite movie to <file> (default: movie-<pid>.mkv)
                           { $::outfile = $file; }
    --outfile <file:of>  \t[ditto]

    -p                   \tpretend (print out commands, but do not run them)
                           { $::pretend = 1; }
    --pretend            \t[ditto]

    -s <n:+i>            \ttarget filesize in megabytes [required]
                           { $::size = $n; }
    --size <n:+i>        \t[ditto]

    -S <n:+i>            \tsubtitle id number
                           { $::sid = "-sid ".$n; }
    --sid <n:+i>         \t[ditto]

    -t <n:+i>            \tdvd title number (default: 1)
                           { $::infile = "dvd://".$n; }
    --title <n:+i>       \t[ditto]

    -w <n:+i>            \tvideo width (default: 640)
                           { # round width to nearest multiple of 16 to make 
                             # codecs more efficient
                             $::width = 16 * int(($n + 8)/16); }
    --width <n:+i>       \t[ditto]
    );

# put tabs in $specification so Getopt::Declare doesn't complain
$specification =~ s/\\t/\t/g;

# $args is not used again--everything was done in blocks above
my $args = Getopt::Declare->new($specification);
exit(1) unless ($args);

my $nice_prefix = ($nice==0 ? "" : "nice -n$nice ");

# a nice function to either run or simply print system calls
sub my_system {
    $_[0] =~ s/[\n ]+/ /gm;
    $_[0] = $nice_prefix.$_[0];
    if($pretend) {
        print "$_[0]\n";
    } else {
        system $_[0];
        if($? == -1) {
            die "Failed to execute command: $_[0]\n";
        } elsif($? >> 8 != 0) {
            die "Command returned with error code: ", $? >> 8, ": $_[0]\n";
        }
    }
}

sub print_options {
    print "# infile     = $infile\n" if $infile;
    print "# outfile    = $outfile\n";
    print "# bitrate    = $bitrate\n" if $bitrate;
    print "# size       = $size\n" if $size;
    print "# width      = $width\n";
    print "# crop       = $crop\n" if $crop;
    print "# dvd-device = $dvd_device\n" if $dvd_device;
    print "# aid        = $aid\n" if $aid;
    print "# sid        = $sid\n" if $sid;
    print "# deinterlacing\n" if $deint;
    print "# denoising\n" if $noise;
    print "# pretend rip\n" if $pretend;
    print "\n";

    if (! $pretend) {
        local $| = 1; #autoflush on for this block
        print "encoding in ";
        for (reverse 1 .. 5) {
            print "$_ ";
            sleep(1);
        }
        print "\n\n";
    }
}

sub get_crop {
    # this part is sorta crazy.  we want to auto-detect the crop region so
    # we spawn mplayer telling it to cropdetect, but to step thru the video
    # 60 seconds at a time but only do a max of 60 frames.  we also tell 
    # it not to show audio or video here since this is just a command line
    # script.  finally we grap the 'crop=...' part from the last line that
    # starts with 'crop area:' since this is the region that mplayer decided
    # is best.
    if($crop eq "auto") {
        print "### Calculating crop region...\n";
        $_ = (grep { /^crop area:/ } `mplayer $dvd_device $infile -vo null \\
            -ao null -vf cropdetect=24:4 -sstep 60 -frames 60 2>/dev/null`)[-1];
        $crop = (/-vf (crop=[\d:]+)/)[0] . ",";
    } elsif($crop) {
        $crop = "crop=$crop,";
    }
}

sub audio_pass {
    print "### Encoding audio...\n";
    # we pass the audio data thru a fifo since mplayer cant encode oggs nativly
    my_system("mkfifo $prefix/pipe${suffix}");
    my_system("oggenc -o $prefix/audio${suffix}.ogg -b 96 $prefix/pipe${suffix} & 
        mplayer -vo null -vc dummy -ao pcm:file=$prefix/pipe${suffix} $infile 
        $aid $dvd_device 2>/dev/null");

    # here we have to calculate the video bitrate if they just gave us a
    # target file size.  first we find the length and size of the audio track.
    # then we find out how much space we have left after subtracting the audio
    # size and container overhead from the target file size.  this crazy
    # calculation gives us or needed bitrate which we then round down to an
    # integer so mencoder doesnt barf.
    if(!$bitrate) {
        if($pretend) {
            # some crazy commands to dynamically determine the video bitrate
            # if we are doing a 'pretend'
            print "\n### Determining video bitrate...\n";
            print "video_bitrate=\$(echo \"($size*1024*1024*.995 - \$(ls -l ", 
            "$prefix/audio${suffix}.ogg | awk '{print \$5}')) / \$(mplayer -frames", 
            "0 -identify -vo null -ao null $prefix/audio${suffix}.ogg 2>/dev/null ",
            "| sed -ne 's/^ID_LENGTH=//p') / 1000 * 8\" | bc -l | sed -e ", 
            "'s/\\..*//')\n";
            $bitrate = "\${video_bitrate}" unless $bitrate;

        } else {
            my $alength = (map { (/^ID_LENGTH=([\d.]+)$/)[0] } 
                `mplayer -v -frames 0 -identify -vo null -ao null \\
                $prefix/audio${suffix}.ogg 2>/dev/null`)[0];
            my $asize = -s "$prefix/audio${suffix}.ogg";
            die "Improper audio length: $alength seconds\n" unless $alength > 0;
            die "Improper audio size: $asize bytes\n" unless $asize > 0;
            $bitrate = int(($size*1024*1024*.995 - $asize)/$alength/1000*8);
            print "# bitrate    = $bitrate\n";
        }
    }
}

sub video1_pass {
    print "\n### Encoding first pass...\n";
    my_system("mencoder $infile -o /dev/null 
        -passlogfile $prefix/divx2pass${suffix}.log -oac copy -ovc x264 -x264encopts 
        pass=1:bitrate=${bitrate}:turbo=1 -vf ${deint}${crop}${noise}scale=$width:-10 
        -zoom $dvd_device $sid -msglevel avsync=5 2>/dev/null");
}

sub video2_pass {
    print "\n### Encoding second pass...\n";
    my_system("mencoder $infile -o $prefix/video${suffix}.avi 
        -passlogfile $prefix/divx2pass${suffix}.log -oac copy -ovc x264 -x264encopts 
        pass=2:bitrate=${bitrate} -vf ${deint}${crop}${noise}scale=$width:-10 
        -zoom $dvd_device $sid -msglevel avsync=5 2>/dev/null");
}

sub mux_pass {
    print "\n### Muxing audio and video...\n";
    my_system("mkvmerge --engage allow_avc_in_vfw_mode --default-language 
        eng -o $outfile -A $prefix/video${suffix}.avi $prefix/audio${suffix}.ogg");
}

sub rm_tmp {
    unlink "$prefix/pipe${suffix}", "$prefix/audio${suffix}.ogg", "$prefix/divx2pass${suffix}.log", "$prefix/video${suffix}.avi";
}

get_crop();
print_options();
audio_pass();
video1_pass();
video2_pass();
mux_pass();
rm_tmp();

=for comment
    
TODO:

make help message not hang
do some testing on the new deinterlacing method
do some testing on the new denoising method
perhaps remove the -i and -t switches so dvds arent a special case
