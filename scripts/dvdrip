#!/usr/bin/perl

use warnings;
use strict;
use Getopt::Declare;

# declaring variables and setting up the defaults
$main::VERSION  = "0.21";
$ENV{MPLAYER_VERBOSE} = "-2";
$SIG{CHLD} = 'IGNORE';

# 'our' lets Getopt::Declare look at these, while 'my' would not
our @aid         = ();
our $bitrate     = "";
our $crop        = "";
our $size        = "700";
our @dvd_device  = ();
our @sid         = ();
our $outfile     = "movie-$$.mkv";
our $deint       = "";
our $pretend     = "";
our $noise       = "";
our $width       = "640";
our $keep        = "0";
our @infiles     = ();
our $temp_dir    = ".";

# Getopt::Declare parameter specifications
# read 'perldoc Getopt::Declare'
# but, in short:
# [strict] makes it die when there's an error
# <n:+i> means match positive integer, store in $n for block
# { block } is executed when an argument is matched
# [ditto] means same as previous argument (and uses same block)
# --switch param \tdescription (need tab immediately before description)
# [required] means this arg or a [ditto] of this arg must be present
# [mutex] means at most one of these args
# Getopt::Declare automatically generates --help output
my $specification = q(
    [pvtype: cr /\d+:\d+:\d+:\d+:?/] # WTF!?! the help message just hangs if
                                     # the regex ends with a '+' so i tacked 
                                     # on a ':?' for no reason
    [mutex: -s --size -b --bitrate]

    -a <n:+i>            \taid number
                           { @::aid = ("-aid", "$n"); }
    --aid <n:+i>         \t[ditto]

    -b <n:+i>            \tbitrate in kbits [required]
                           { $::bitrate = $n;
                             $::size = ""; }
    --bitrate <n:+i>     \t[ditto]

    -c [<region:cr>]     \tcrop borders (omit region to auto-detect)
                           { $::crop = "auto"; 
                             $::crop = $region if $region; }
    --crop [<region:cr>] \t[ditto]

    -d <path>            \tdvd device (default: /dev/dvd)
                           { @::dvd_device = ("-dvd-device", "$path"); }
    --dvd-device <path>  \t[ditto]

    -k                   \tkeep temp files when finished
                           { $::keep = 1; }
    --keep               \t[ditto]

    -l                   \tdeinterlace video
                           { # maybe switch to pullup,softskip
                             # will prob need -ofps 24000/1001 too
                             $::deint = "lavcdeint,"; }
    --deinterlace        \t[ditto]

    -n                   \tdenoise video
                           { $::noise = "hqdn3d,"; }
    --denoise            \t[ditto]

    -o <file:of>         \twrite movie to <file> (default: movie-<pid>.mkv)
                           { $file =~ s/(['" \\\\])/\\\\$1/g;
                             $::outfile = $file; }
    --outfile <file:of>  \t[ditto]

    -p                   \tpretend (print out commands, but do not run them)
                           { $::pretend = 1; }
    --pretend            \t[ditto]

    -s <n:+i>            \ttarget filesize in megabytes [required]
                           { $::size = $n; }
    --size <n:+i>        \t[ditto]

    -S <n:+i>            \tsubtitle id number
                           { @::sid = ("-sid", "$n"); }
    --sid <n:+i>         \t[ditto]

    -w <n:+i>            \tvideo width (default: 640)
                           { # round width to nearest multiple of 16 to make 
                             # codecs more efficient
                             $::width = 16 * int(($n + 8)/16); }
    --width <n:+i>       \t[ditto]

    -i                   \t(deprecated, do not use)
                           { print "The '-i' and '-t' options are deprecated, ", 
                             "please look at the help output.\n";
                             exit 1; }
    --infile             \t[ditto]
    -t                   \t[ditto]
    --title              \t[ditto]

    <infiles>...         \tinput files [required][repeatable]
                           { for(@infiles) {
                                unless(m#^dvd://\\d+$# || -r $_) {
                                    print "Input file '$_' is not a valid ", 
                                    "dvd track or readable input file\n";
                                    exit 1;
                                }
                                push @::infiles, $_;
                             }
                           }
    );

# put tabs in $specification so Getopt::Declare doesn't complain
$specification =~ s/\\t/\t/g;

# $args is not used again--everything was done in blocks above
my $args = Getopt::Declare->new($specification);
exit(1) unless ($args);

# a nice function to either run or simply print system calls
sub my_system {
    if($pretend) {
        print "@_\n";
    } else {
        system @_;
        #if($? == -1) {
        #    die "Failed to execute command: @_\n";
        #} elsif($? >> 8 != 0) {
        #    die "Command returned with error code: ", $? >> 8, ": @_\n";
        #}
    }
}

sub print_options {
    print "# infiles     = @infiles\n";
    print "# outfile     = $outfile\n";
    print "# bitrate     = $bitrate\n" if $bitrate;
    print "# size        = $size\n" if $size;
    print "# width       = $width\n";
    print "# crop        = $crop\n" if $crop;
    print "# dvd-device  = @dvd_device\n" if @dvd_device;
    print "# aid         = @aid\n" if @aid;
    print "# sid         = @sid\n" if @sid;
    print "# deinterlacing\n" if $deint;
    print "# denoising\n" if $noise;
    print "# pretend rip\n" if $pretend;
    print "\n";

    if(!$pretend) {
        local $| = 1; #autoflush on for this block
        print "encoding in... ";
        for (reverse 1 .. 5) {
            print "$_ ";
            sleep(1);
        }
        print "\n\n";
    }
}

sub get_crop {
    # this part is sorta crazy.  we want to auto-detect the crop region so
    # we spawn mplayer telling it to cropdetect, but to step thru the video
    # 60 seconds at a time but only do a max of 60 frames.  we also tell 
    # it not to show audio or video here since this is just a command line
    # script.  finally we grap the 'crop=...' part from the last line that
    # starts with 'crop area:' since this is the region that mplayer decided
    # is best.
    if($crop eq "auto") {
        print "### Calculating crop region...\n";
        open CROP, '-|', "mplayer", @dvd_device, @infiles, 
            qw(-vo null -ao null -vf cropdetect=50:4 -sstep 60 -frames 60);
        $_ = (<CROP>)[-1];
        $crop = (/-vf (crop=[\d:]+)/)[0];
        die "Could not auto-detect crop region\n" unless $crop;
        $crop .= ","
    } elsif($crop) {
        $crop = "crop=$crop,";
    }
}

sub audio_pass {
    print "### Encoding audio...\n";
    # we pass the audio data thru a fifo since mplayer cant encode oggs nativly
    my_system("mkfifo", "$temp_dir/pipe-$$");
    my $ppid = $$;
    if(!fork) {
        my_system(qw(oggenc -b 96 -o), "$temp_dir/audio-$ppid.ogg", 
            "$temp_dir/pipe-$ppid");
        exit;
    }
    my_system(qw"mplayer -vo null -vc dummy -ao", "pcm:file=$temp_dir/pipe-$$",
        @infiles, @aid, @dvd_device);

    # give oggenc some time to finish encoding whats left in the pipe, since
    # mplayer will return before oggenc is done
    sleep 1 unless $pretend;

    # here we have to calculate the video bitrate if they just gave us a
    # target file size.  first we find the length and size of the audio track.
    # then we find out how much space we have left after subtracting the audio
    # size and container overhead from the target file size.  this crazy
    # calculation gives us our needed bitrate which we then round down to an
    # integer so mencoder doesnt barf.
    if(!$bitrate) {
        if($pretend) {
            # some crazy commands to dynamically determine the video bitrate
            # if we are doing a 'pretend'
            print "\n### Determining video bitrate...\n";
            print "video_bitrate=\$(echo \"($size*1024*1024*.995 - \$(ls -l ", 
            "$temp_dir/audio-$$.ogg | awk '{print \$5}')) / \$(mplayer -frames ", 
            "0 -identify -vo null -ao null $temp_dir/audio-$$.ogg 2>/dev/null ",
            "| sed -ne 's/^ID_LENGTH=//p') / 1000 * 8\" | bc -l | sed -e ", 
            "'s/\\..*//')\n";
            $bitrate = "\${video_bitrate}" unless $bitrate;
        } else {
            open INDENT, "-|", qw(mplayer -v -frames 0 -identify -vo null -ao null), 
                "$temp_dir/audio-$$.ogg";
            my $alength = (grep { /^ID_LENGTH=[\d.]+$/ } (<INDENT>))[0];
            $alength =~ s/^ID_LENGTH=([\d.]+)$/$1/;
            chomp $alength;
            my $asize = -s "$temp_dir/audio-$$.ogg";
            die "Improper audio length: $alength seconds\n" unless $alength > 0;
            die "Improper audio size: $asize bytes\n" unless $asize > 0;
            $bitrate = int(($size*1024*1024*.995 - $asize)/$alength/1000*8);
            print  "\n";
            printf "# alength     = %.2f seconds\n", $alength;
            printf "# asize       = %.2f mb\n", $asize/1024/1024;
            print  "# bitrate     = $bitrate kbit\n";
        }
    }
}

sub video1_pass {
    print "\n### Encoding first pass...\n";
    my_system(qw(mencoder -oac copy -ovc x264 -zoom -msglevel avsync=5), 
        @infiles, "-passlogfile", "$temp_dir/divx2pass-$$.log", "-o", 
        "/dev/null", "-x264encopts", "pass=1:bitrate=${bitrate}:turbo=1", 
        "-vf", "${deint}${crop}${noise}scale=$width:-10", @dvd_device, 
        @sid);
}

sub video2_pass {
    print "\n### Encoding second pass...\n";
    my_system(qw(mencoder -oac copy -ovc x264 -zoom -msglevel avsync=5),
        @infiles, "-passlogfile", "$temp_dir/divx2pass-$$.log", "-o",
        "$temp_dir/video-$$.avi", "-x264encopts", "pass=2:bitrate=${bitrate}", 
        "-vf", "${deint}${crop}${noise}scale=$width:-10", @dvd_device,
        @sid);
}

sub mux_pass {
    print "\n### Muxing audio and video...\n";
    my_system(qw(mkvmerge --engage allow_avc_in_vfw_mode --default-language 
        eng -o), "$outfile", "-A", "$temp_dir/video-$$.avi", 
        "$temp_dir/audio-$$.ogg");
}

sub rm_tmp {
    return if $pretend;
    # remove the temp files unless the user told us not to or unless the final 
    # file size is off by more than 2 percent
    if($size) {
        my $final_size = -s $outfile;
        my $diff = ($final_size/1024/1024 - $size) / $size * 100;
        print "# target size = $size\n";
        printf "# actual size = %.0f\n", $final_size/1024/1024;
        if($diff >= 2 || $diff <= -2) {
            print "Final file size off by more than 2%, keeping temp files\n";
            $keep = 1;
        }
    }
    unless($keep) { 
        unlink "$temp_dir/pipe-$$", "$temp_dir/audio-$$.ogg", 
        "$temp_dir/divx2pass-$$.log", "$temp_dir/video-$$.avi";
    }
}

get_crop();
print_options();
audio_pass();
video1_pass();
video2_pass();
mux_pass();
rm_tmp();

=for comment
    
TODO:

do some testing on the new deinterlacing method
switch to Getopt::Long so i have more control over the help message
add a switch for setting the directory for the temp files
